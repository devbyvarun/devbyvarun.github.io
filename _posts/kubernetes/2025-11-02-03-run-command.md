---
title: "Kubernetes Run Command"
date: 2025-11-02 12:00:00 -0700
categories: [Kubernetes]
tags: [kubernetes, intro]
description: "`kubectl run` is a command used to create and run a single Pod in a Kubernetes cluster using a specified container image.
"
---

# Complete Guide to kubectl run Command

The `kubectl run` command is one of the most fundamental commands in Kubernetes for creating and managing Pods. Originally, it could create Deployments, Jobs, and more, but since Kubernetes v1.18+, it's focused mainly on creating Pods for simplicity and consistency.

## Table of Contents
1. [Basic Syntax](#basic-syntax)
2. [Core Options](#core-options)
3. [Resource Control](#resource-control)
4. [Container Configuration](#container-configuration)
5. [Networking & Storage](#networking--storage)
6. [Advanced Usage](#advanced-usage)
7. [Practical Examples](#practical-examples)
8. [Best Practices](#best-practices)

## Basic Syntax

```bash
kubectl run <pod-name> --image=<image-name> [options]
```

### Simple Example
```bash
kubectl run nginx --image=nginx
```

This command creates a Pod named `nginx` using the nginx container image in the default namespace.

## Core Options

### Essential Flags

| Flag | Description | Example | Default |
|------|-------------|---------|---------|
| `--image` | Container image to use (required) | `--image=nginx:1.21` | None |
| `--restart` | Restart policy | `--restart=Never` | `Always` |
| `--dry-run` | Simulation mode | `--dry-run=client` | `none` |
| `-o, --output` | Output format | `-o yaml` | None |
| `--rm` | Delete Pod after completion | `--rm` | `false` |

### Restart Policy Details

| Value | Resource Created | Behavior | Use Case |
|-------|-----------------|----------|----------|
| `Always` | Deployment | Pod restarts automatically | Long-running applications |
| `OnFailure` | Job | Restarts only on failure | Batch processing |
| `Never` | Pod | No automatic restart | One-time tasks, debugging |

### Dry Run Options

| Value | Behavior | Use Case |
|-------|----------|----------|
| `none` | Execute normally | Actually create resources |
| `client` | Local validation only | Generate YAML manifests |
| `server` | Server-side validation | Test API server validation |

## Resource Control

### Resource Limits and Requests

| Flag | Description | Example |
|------|-------------|---------|
| `--requests` | Resource requests | `--requests='cpu=100m,memory=128Mi'` |
| `--limits` | Resource limits | `--limits='cpu=200m,memory=256Mi'` |

### Node Selection

| Flag | Description | Example |
|------|-------------|---------|
| `--node-selector` | Node selector labels | `--node-selector='disktype=ssd'` |
| `--tolerations` | Pod tolerations | `--tolerations='key=value:NoSchedule'` |

## Container Configuration

### Environment Variables

| Flag | Description | Example |
|------|-------------|---------|
| `--env` | Set environment variable | `--env="API_KEY=secret123"` |
| `--env-from` | Load env from ConfigMap/Secret | `--env-from='configmap/app-config'` |

### Command and Arguments

| Flag | Description | Example |
|------|-------------|---------|
| `--command` | Override container entrypoint | `--command -- /bin/sh` |
| `-- <args>` | Arguments to command | `-- -c 'echo hello'` |

### Interactive Mode

| Flag | Description | Example |
|------|-------------|---------|
| `-i, --stdin` | Keep STDIN open | `-i` |
| `-t, --tty` | Allocate a TTY | `-t` |
| `-it` | Interactive with TTY | `-it` |

### Image Configuration

| Flag | Description | Example |
|------|-------------|---------|
| `--image-pull-policy` | When to pull image | `--image-pull-policy=Always` |

#### Image Pull Policy Options

| Value | Behavior | When to Use |
|-------|----------|-------------|
| `Always` | Pull image every time | Latest tags, active development |
| `IfNotPresent` | Pull only if not cached | Stable tagged images |
| `Never` | Use only local images | Offline testing, preloaded images |

## Networking & Storage

### Port Configuration

| Flag | Description | Example |
|------|-------------|---------|
| `--port` | Container port to expose | `--port=8080` |
| `--expose` | Create a Service | `--expose --port=80` |

### Service Account and Security

| Flag | Description | Example |
|------|-------------|---------|
| `--serviceaccount` | Service account name | `--serviceaccount=my-sa` |
| `--privileged` | Run in privileged mode | `--privileged` |

### Labels and Annotations

| Flag | Description | Example |
|------|-------------|---------|
| `-l, --labels` | Add labels | `--labels='app=web,version=v1'` |
| `--annotations` | Add annotations | `--annotations='description=test-pod'` |

## Advanced Usage

### Namespace Management

| Flag | Description | Example |
|------|-------------|---------|
| `-n, --namespace` | Target namespace | `-n production` |

### Advanced Scheduling

| Flag | Description | Example |
|------|-------------|---------|
| `--schedule` | Cron schedule (CronJob) | `--schedule='0 */6 * * *'` |
| `--job-timeout` | Job timeout | `--job-timeout=300s` |

## Practical Examples

### 1. Basic Pod Creation
```bash
# Create a simple nginx Pod
kubectl run nginx --image=nginx

# Create Pod in specific namespace
kubectl run nginx --image=nginx -n development
```

### 2. One-time Tasks
```bash
# Run a command once and exit
kubectl run hello --image=busybox --restart=Never -- echo "Hello World"

# Run with environment variables
kubectl run app --image=alpine --restart=Never --env="MODE=production" -- printenv MODE
```

### 3. Interactive Debugging
```bash
# Start interactive shell (temporary)
kubectl run debug --image=busybox -it --rm -- sh

# Debug with specific image
kubectl run ubuntu-debug --image=ubuntu -it --rm -- bash
```

### 4. Resource-constrained Pods
```bash
# Pod with resource limits
kubectl run limited-pod --image=nginx \
  --requests='cpu=100m,memory=128Mi' \
  --limits='cpu=200m,memory=256Mi'
```

### 5. Generating YAML Manifests
```bash
# Generate Pod YAML without creating it
kubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml > pod.yaml

# Generate Deployment YAML
kubectl run nginx --image=nginx --dry-run=client -o yaml > deployment.yaml
```

### 6. Jobs and Batch Processing
```bash
# Create a Job that retries on failure
kubectl run batch-job --image=busybox --restart=OnFailure -- /bin/sh -c 'exit 1'

# Job with timeout
kubectl run timed-job --image=busybox --restart=OnFailure --job-timeout=60s -- sleep 30
```

### 7. Network and Port Configuration
```bash
# Expose container port
kubectl run web --image=nginx --port=80

# Create Pod and Service together
kubectl run web --image=nginx --port=80 --expose
```

### 8. Security Contexts
```bash
# Run with specific service account
kubectl run secure-pod --image=nginx --serviceaccount=my-service-account

# Run privileged container
kubectl run privileged-pod --image=busybox --privileged --restart=Never -- id
```

### 9. Node Placement
```bash
# Schedule on specific node type
kubectl run gpu-pod --image=tensorflow/tensorflow:latest-gpu \
  --node-selector='accelerator=nvidia-tesla-k80'
```

### 10. Multiple Environment Variables
```bash
# Set multiple environment variables
kubectl run config-pod --image=busybox --restart=Never \
  --env="API_URL=https://api.example.com" \
  --env="DEBUG=true" \
  --env="TIMEOUT=30" \
  -- printenv
```

## Best Practices

### Development and Testing
- Use `--restart=Never` for debugging and one-time tasks
- Use `--rm` for temporary Pods that should be cleaned up automatically
- Use `--dry-run=client -o yaml` to generate manifests for version control

### Production Considerations
- Avoid using `kubectl run` for production workloads; use Deployments instead
- Always specify resource requests and limits
- Use specific image tags instead of `latest`
- Set appropriate restart policies based on workload type

### Security Best Practices
- Use dedicated service accounts instead of default
- Avoid `--privileged` unless absolutely necessary
- Set appropriate security contexts and Pod security policies

### Debugging Workflows
```bash
# Quick debug container
kubectl run debug --image=busybox -it --rm -- sh

# Debug with network tools
kubectl run netdebug --image=nicolaka/netshoot -it --rm -- bash

# Debug with curl
kubectl run curl --image=curlimages/curl -it --rm -- sh
```

### Common Command Patterns

#### Generate and Apply Pattern
```bash
# Generate, modify, then apply
kubectl run myapp --image=nginx --dry-run=client -o yaml > myapp.yaml
# Edit myapp.yaml as needed
kubectl apply -f myapp.yaml
```

#### Quick Test Pattern
```bash
# Test image quickly
kubectl run test-$(date +%s) --image=myapp:latest -it --rm --restart=Never -- /app/healthcheck
```

#### Job Monitoring Pattern
```bash
# Create job and monitor
kubectl run import-job --image=myapp:latest --restart=OnFailure -- /app/import-data
kubectl logs -f job/import-job
```

## Comparison with Other Commands

### kubectl run vs kubectl create deployment
```bash
# kubectl run (creates Pod)
kubectl run nginx --image=nginx --restart=Never

# kubectl create deployment (creates Deployment)
kubectl create deployment nginx --image=nginx
```

### kubectl run vs kubectl exec
```bash
# kubectl run (creates new Pod)
kubectl run debug --image=busybox -it --rm -- sh

# kubectl exec (connects to existing Pod)
kubectl exec -it existing-pod -- sh
```

This comprehensive guide covers all major aspects of the `kubectl run` command, from basic usage to advanced scenarios. Whether you're debugging, testing, or creating temporary workloads, `kubectl run` provides a flexible and powerful interface for Pod management in Kubernetes.
